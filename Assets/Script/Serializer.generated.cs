// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168
#pragma warning disable CS1591 // document public APIs

#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Resolvers
{
    public class GeneratedResolver : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new GeneratedResolver();

        private GeneratedResolver()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
            return FormatterCache<T>.Formatter;
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class GeneratedResolverGetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<global::System.Type, int> lookup;

        static GeneratedResolverGetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<global::System.Type, int>(18)
            {
                { typeof(global::ChangeImage[]), 0 },
                { typeof(global::Content[]), 1 },
                { typeof(global::Location[]), 2 },
                { typeof(global::QuestionData[]), 3 },
                { typeof(global::System.Collections.Generic.Dictionary<string, bool>), 4 },
                { typeof(global::System.Collections.Generic.KeyValuePair<string, bool>), 5 },
                { typeof(global::System.Collections.Generic.KeyValuePair<string, bool>[]), 6 },
                { typeof(global::System.Collections.Generic.List<string>), 7 },
                { typeof(global::ChangeImage), 8 },
                { typeof(global::Content), 9 },
                { typeof(global::FlagCondition), 10 },
                { typeof(global::FlagData), 11 },
                { typeof(global::InventoryData), 12 },
                { typeof(global::Location), 13 },
                { typeof(global::MapData), 14 },
                { typeof(global::ObjectData), 15 },
                { typeof(global::QuestionData), 16 },
                { typeof(global::TalkData), 17 },
            };
        }

        internal static object GetFormatter(global::System.Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
                case 0: return new global::MessagePack.Formatters.ArrayFormatter<global::ChangeImage>();
                case 1: return new global::MessagePack.Formatters.ArrayFormatter<global::Content>();
                case 2: return new global::MessagePack.Formatters.ArrayFormatter<global::Location>();
                case 3: return new global::MessagePack.Formatters.ArrayFormatter<global::QuestionData>();
                case 4: return new global::MessagePack.Formatters.DictionaryFormatter<string, bool>();
                case 5: return new global::MessagePack.Formatters.KeyValuePairFormatter<string, bool>();
                case 6: return new global::MessagePack.Formatters.ArrayFormatter<global::System.Collections.Generic.KeyValuePair<string, bool>>();
                case 7: return new global::MessagePack.Formatters.ListFormatter<string>();
                case 8: return new MessagePack.Formatters.ChangeImageFormatter();
                case 9: return new MessagePack.Formatters.ContentFormatter();
                case 10: return new MessagePack.Formatters.FlagConditionFormatter();
                case 11: return new MessagePack.Formatters.FlagDataFormatter();
                case 12: return new MessagePack.Formatters.InventoryDataFormatter();
                case 13: return new MessagePack.Formatters.LocationFormatter();
                case 14: return new MessagePack.Formatters.MapDataFormatter();
                case 15: return new MessagePack.Formatters.ObjectDataFormatter();
                case 16: return new MessagePack.Formatters.QuestionDataFormatter();
                case 17: return new MessagePack.Formatters.TalkDataFormatter();
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1649 // File name should match first type name




// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168
#pragma warning disable CS1591 // document public APIs

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace MessagePack.Formatters
{
    public sealed class ChangeImageFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ChangeImage>
    {
        // ImageName
        private static global::System.ReadOnlySpan<byte> GetSpan_ImageName() => new byte[1 + 9] { 169, 73, 109, 97, 103, 101, 78, 97, 109, 101 };
        // SpriteName
        private static global::System.ReadOnlySpan<byte> GetSpan_SpriteName() => new byte[1 + 10] { 170, 83, 112, 114, 105, 116, 101, 78, 97, 109, 101 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::ChangeImage value, global::MessagePack.MessagePackSerializerOptions options)
        {
            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(2);
            writer.WriteRaw(GetSpan_ImageName());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.ImageName, options);
            writer.WriteRaw(GetSpan_SpriteName());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.SpriteName, options);
        }

        public global::ChangeImage Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new global::System.InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::ChangeImage();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 9:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_ImageName().Slice(1))) { goto FAIL; }

                        ____result.ImageName = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 10:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_SpriteName().Slice(1))) { goto FAIL; }

                        ____result.SpriteName = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ContentFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Content>
    {
        // Speaker
        private static global::System.ReadOnlySpan<byte> GetSpan_Speaker() => new byte[1 + 7] { 167, 83, 112, 101, 97, 107, 101, 114 };
        // Text
        private static global::System.ReadOnlySpan<byte> GetSpan_Text() => new byte[1 + 4] { 164, 84, 101, 120, 116 };
        // ChangeImage
        private static global::System.ReadOnlySpan<byte> GetSpan_ChangeImage() => new byte[1 + 11] { 171, 67, 104, 97, 110, 103, 101, 73, 109, 97, 103, 101 };
        // QuestionData
        private static global::System.ReadOnlySpan<byte> GetSpan_QuestionData() => new byte[1 + 12] { 172, 81, 117, 101, 115, 116, 105, 111, 110, 68, 97, 116, 97 };
        // BGM
        private static global::System.ReadOnlySpan<byte> GetSpan_BGM() => new byte[1 + 3] { 163, 66, 71, 77 };
        // SE
        private static global::System.ReadOnlySpan<byte> GetSpan_SE() => new byte[1 + 2] { 162, 83, 69 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Content value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(6);
            writer.WriteRaw(GetSpan_Speaker());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.Speaker, options);
            writer.WriteRaw(GetSpan_Text());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.Text, options);
            writer.WriteRaw(GetSpan_ChangeImage());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::ChangeImage[]>(formatterResolver).Serialize(ref writer, value.ChangeImage, options);
            writer.WriteRaw(GetSpan_QuestionData());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::QuestionData[]>(formatterResolver).Serialize(ref writer, value.QuestionData, options);
            writer.WriteRaw(GetSpan_BGM());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.BGM, options);
            writer.WriteRaw(GetSpan_SE());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.SE, options);
        }

        public global::Content Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::Content();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 7:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 32199659214958675UL) { goto FAIL; }

                        ____result.Speaker = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 4:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 1954047316UL) { goto FAIL; }

                        ____result.Text = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 11:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_ChangeImage().Slice(1))) { goto FAIL; }

                        ____result.ChangeImage = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::ChangeImage[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 12:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_QuestionData().Slice(1))) { goto FAIL; }

                        ____result.QuestionData = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::QuestionData[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 3:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 5064514UL) { goto FAIL; }

                        ____result.BGM = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 2:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 17747UL) { goto FAIL; }

                        ____result.SE = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class FlagConditionFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::FlagCondition>
    {
        // Flag
        private static global::System.ReadOnlySpan<byte> GetSpan_Flag() => new byte[1 + 4] { 164, 70, 108, 97, 103 };
        // NextFlag
        private static global::System.ReadOnlySpan<byte> GetSpan_NextFlag() => new byte[1 + 8] { 168, 78, 101, 120, 116, 70, 108, 97, 103 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::FlagCondition value, global::MessagePack.MessagePackSerializerOptions options)
        {
            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(2);
            writer.WriteRaw(GetSpan_Flag());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Serialize(ref writer, value.Flag, options);
            writer.WriteRaw(GetSpan_NextFlag());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Serialize(ref writer, value.NextFlag, options);
        }

        public global::FlagCondition Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new global::System.InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::FlagCondition();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 4:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 1734437958UL) { goto FAIL; }

                        ____result.Flag = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 8:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 7449354308505068878UL) { goto FAIL; }

                        ____result.NextFlag = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class FlagDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::FlagData>
    {
        // Flags
        private static global::System.ReadOnlySpan<byte> GetSpan_Flags() => new byte[1 + 5] { 165, 70, 108, 97, 103, 115 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::FlagData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(1);
            writer.WriteRaw(GetSpan_Flags());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<string, bool>>(formatterResolver).Serialize(ref writer, value.Flags, options);
        }

        public global::FlagData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::FlagData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 5:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 495655676998UL) { goto FAIL; }

                        ____result.Flags = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.Dictionary<string, bool>>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class InventoryDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::InventoryData>
    {
        // Items
        private static global::System.ReadOnlySpan<byte> GetSpan_Items() => new byte[1 + 5] { 165, 73, 116, 101, 109, 115 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::InventoryData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(1);
            writer.WriteRaw(GetSpan_Items());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.List<string>>(formatterResolver).Serialize(ref writer, value.Items, options);
        }

        public global::InventoryData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::InventoryData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 5:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 495756604489UL) { goto FAIL; }

                        ____result.Items = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.List<string>>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class LocationFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Location>
    {
        // MapName
        private static global::System.ReadOnlySpan<byte> GetSpan_MapName() => new byte[1 + 7] { 167, 77, 97, 112, 78, 97, 109, 101 };
        // Position
        private static global::System.ReadOnlySpan<byte> GetSpan_Position() => new byte[1 + 8] { 168, 80, 111, 115, 105, 116, 105, 111, 110 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Location value, global::MessagePack.MessagePackSerializerOptions options)
        {
            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(2);
            writer.WriteRaw(GetSpan_MapName());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.MapName, options);
            writer.WriteRaw(GetSpan_Position());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::UnityEngine.Vector2Int>(formatterResolver).Serialize(ref writer, value.Position, options);
        }

        public global::Location Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new global::System.InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::Location();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 7:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 28549237343019341UL) { goto FAIL; }

                        ____result.MapName = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 8:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 7957695015293251408UL) { goto FAIL; }

                        ____result.Position = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::UnityEngine.Vector2Int>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class MapDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::MapData>
    {
        // Tiles
        private static global::System.ReadOnlySpan<byte> GetSpan_Tiles() => new byte[1 + 5] { 165, 84, 105, 108, 101, 115 };
        // StylesFront
        private static global::System.ReadOnlySpan<byte> GetSpan_StylesFront() => new byte[1 + 11] { 171, 83, 116, 121, 108, 101, 115, 70, 114, 111, 110, 116 };
        // StylesMiddle
        private static global::System.ReadOnlySpan<byte> GetSpan_StylesMiddle() => new byte[1 + 12] { 172, 83, 116, 121, 108, 101, 115, 77, 105, 100, 100, 108, 101 };
        // StylesBack
        private static global::System.ReadOnlySpan<byte> GetSpan_StylesBack() => new byte[1 + 10] { 170, 83, 116, 121, 108, 101, 115, 66, 97, 99, 107 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::MapData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(4);
            writer.WriteRaw(GetSpan_Tiles());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Serialize(ref writer, value.Tiles, options);
            writer.WriteRaw(GetSpan_StylesFront());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Serialize(ref writer, value.StylesFront, options);
            writer.WriteRaw(GetSpan_StylesMiddle());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Serialize(ref writer, value.StylesMiddle, options);
            writer.WriteRaw(GetSpan_StylesBack());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Serialize(ref writer, value.StylesBack, options);
        }

        public global::MapData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::MapData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 5:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 495622842708UL) { goto FAIL; }

                        ____result.Tiles = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 11:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_StylesFront().Slice(1))) { goto FAIL; }

                        ____result.StylesFront = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 12:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_StylesMiddle().Slice(1))) { goto FAIL; }

                        ____result.StylesMiddle = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 10:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_StylesBack().Slice(1))) { goto FAIL; }

                        ____result.StylesBack = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class ObjectDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::ObjectData>
    {
        // Id
        private static global::System.ReadOnlySpan<byte> GetSpan_Id() => new byte[1 + 2] { 162, 73, 100 };
        // Location
        private static global::System.ReadOnlySpan<byte> GetSpan_Location() => new byte[1 + 8] { 168, 76, 111, 99, 97, 116, 105, 111, 110 };
        // EventName
        private static global::System.ReadOnlySpan<byte> GetSpan_EventName() => new byte[1 + 9] { 169, 69, 118, 101, 110, 116, 78, 97, 109, 101 };
        // TriggerType
        private static global::System.ReadOnlySpan<byte> GetSpan_TriggerType() => new byte[1 + 11] { 171, 84, 114, 105, 103, 103, 101, 114, 84, 121, 112, 101 };
        // FlagCondition
        private static global::System.ReadOnlySpan<byte> GetSpan_FlagCondition() => new byte[1 + 13] { 173, 70, 108, 97, 103, 67, 111, 110, 100, 105, 116, 105, 111, 110 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::ObjectData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(5);
            writer.WriteRaw(GetSpan_Id());
            writer.Write(value.Id);
            writer.WriteRaw(GetSpan_Location());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::Location[]>(formatterResolver).Serialize(ref writer, value.Location, options);
            writer.WriteRaw(GetSpan_EventName());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.EventName, options);
            writer.WriteRaw(GetSpan_TriggerType());
            writer.Write(value.TriggerType);
            writer.WriteRaw(GetSpan_FlagCondition());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::FlagCondition>(formatterResolver).Serialize(ref writer, value.FlagCondition, options);
        }

        public global::ObjectData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::ObjectData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 2:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 25673UL) { goto FAIL; }

                        ____result.Id = reader.ReadInt32();
                        continue;
                    case 8:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 7957695015157985100UL) { goto FAIL; }

                        ____result.Location = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::Location[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 9:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_EventName().Slice(1))) { goto FAIL; }

                        ____result.EventName = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 11:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_TriggerType().Slice(1))) { goto FAIL; }

                        ____result.TriggerType = reader.ReadInt32();
                        continue;
                    case 13:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_FlagCondition().Slice(1))) { goto FAIL; }

                        ____result.FlagCondition = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::FlagCondition>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class QuestionDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::QuestionData>
    {
        // Answer
        private static global::System.ReadOnlySpan<byte> GetSpan_Answer() => new byte[1 + 6] { 166, 65, 110, 115, 119, 101, 114 };
        // NextFlag
        private static global::System.ReadOnlySpan<byte> GetSpan_NextFlag() => new byte[1 + 8] { 168, 78, 101, 120, 116, 70, 108, 97, 103 };
        // NextTalkData
        private static global::System.ReadOnlySpan<byte> GetSpan_NextTalkData() => new byte[1 + 12] { 172, 78, 101, 120, 116, 84, 97, 108, 107, 68, 97, 116, 97 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::QuestionData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(3);
            writer.WriteRaw(GetSpan_Answer());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.Answer, options);
            writer.WriteRaw(GetSpan_NextFlag());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Serialize(ref writer, value.NextFlag, options);
            writer.WriteRaw(GetSpan_NextTalkData());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Serialize(ref writer, value.NextTalkData, options);
        }

        public global::QuestionData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                throw new global::System.InvalidOperationException("typecode is null, struct not supported");
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::QuestionData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 6:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 125780121316929UL) { goto FAIL; }

                        ____result.Answer = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 8:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 7449354308505068878UL) { goto FAIL; }

                        ____result.NextFlag = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::System.Collections.Generic.KeyValuePair<string, bool>[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;
                    case 12:
                        if (!global::System.MemoryExtensions.SequenceEqual(stringKey, GetSpan_NextTalkData().Slice(1))) { goto FAIL; }

                        ____result.NextTalkData = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<string>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

    public sealed class TalkDataFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::TalkData>
    {
        // Content
        private static global::System.ReadOnlySpan<byte> GetSpan_Content() => new byte[1 + 7] { 167, 67, 111, 110, 116, 101, 110, 116 };

        public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::TalkData value, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNil();
                return;
            }

            var formatterResolver = options.Resolver;
            writer.WriteMapHeader(1);
            writer.WriteRaw(GetSpan_Content());
            global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::Content[]>(formatterResolver).Serialize(ref writer, value.Content, options);
        }

        public global::TalkData Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
                return null;
            }

            options.Security.DepthStep(ref reader);
            var formatterResolver = options.Resolver;
            var length = reader.ReadMapHeader();
            var ____result = new global::TalkData();

            for (int i = 0; i < length; i++)
            {
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                      reader.Skip();
                      continue;
                    case 7:
                        if (global::MessagePack.Internal.AutomataKeyGen.GetKey(ref stringKey) != 32772479322582851UL) { goto FAIL; }

                        ____result.Content = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<global::Content[]>(formatterResolver).Deserialize(ref reader, options);
                        continue;

                }
            }

            reader.Depth--;
            return ____result;
        }
    }

}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1129 // Do not use default value type constructor
#pragma warning restore SA1309 // Field names should not begin with underscore
#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1403 // File may only contain a single namespace
#pragma warning restore SA1649 // File name should match first type name

